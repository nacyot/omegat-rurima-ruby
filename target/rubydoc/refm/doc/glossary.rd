= Ruby 용어집

=== A


: AWK
   엘프리드 에이호, 피터 와인, 브라이언 케니핸에 의해 만들어진
  경량 스크립트 언어.

=== B


: blade
  ml archive ([[url:http://blade.nagaokaut.ac.jp/ruby/]])

=== C


: Coerce
  숫자값의 타입을 변환하는 메소드.수치계산을 하는 메소드는 자신이 이해하지 못 하는
  인스턴스가 인수로 주어졌을 때 coerce
  메소드를 사용해서 형변화를 하도록 되어있다.
  coerce 메소드는 인수로서 넘겨진 값(을 변환한 값)과
  자신(필요하다면 변환한 값)의 쌍을 반환한다.

  Ruby 라이브러리의 수치 타입의 변환 순서는 다음과 같다.

            Fixnum -> Bignum -> Rational -> Float -> Complex

  になっている。

=== D


: Data
  C의 포인터를 Ruby 객체로 보여주기 위한 래퍼.
  C포인터와 mark함수, free함수로부터 만들어진다.C를 사용해 Ruby의 기능
  을 추가하려고 하는 사람이라면 반드시 이 클래스의 사용법을 마스터할
  필요가 있다.거꾸로 말하면 그렇지 않은 사람에면 필요하지 않은 클래스
  이기도 하다.

: defined?  어떤 식이 정말로 정의되어있는지 알아볼 수 있는
  연산자정의되어있지 않은 경우는 nil을 리턴하고, 정의되어있는 경우엔
  그 식의 종류를 나타내는 문자열을 리턴한다.defined?은
  메소드처럼 보이지만 Ruby 문법에 포함된 연산자로 인수를
  평가하지 않는다.따라서
//emlist{
            defined?print("abc\n")
//}
  와 같은 구문은 아무것도 출력하지 않는다.

=== E


: Eiffel
  객체 지향 프로그래밍 언어.matz는 오래전 이 언어를 만든 Bertrand Meyer의 저서
  Object-oriented Software Construction
  를 읽고 깨달음을 얻었다고 한다.그럼에도 불구하고 Ruby는
  Eiffel과 닮지 않았다.비슷한 점은 블록이 end로 
  끝나는 점과, rescue가 예약어라는 점 정도

: end
  블록 구조를 마치는 예약어.어떤 통계에 따르면 Ruby를 처음 본 사람의
  33%는 이 키워드를 보고 Pascal을 연상한다고 한다. (거짓말)하지만 
  end가 begin과 쌍을 이루지 않는다는 점에선 Pascal보다는 Ada나 Eiffel
  에 가깝다.

  Ruby는 C나 Perl에서 사용하는 {} 문법을 아래와 같은 이유에서
  사용하지 않았다.

  * 단문, 복문 문제의 회피

    예를 들어 C에서는
//emlist{
              if (a==b)
                 c();
//}
    에 문을 추가하려고
//emlist{
              if (a==b)
                 c();
                 d();
//}
    을 추가하면 까다로운 문제가 발생한다.이 문제는 Pascal에도
    존재한다.

  * 늘어지는 else 문제의 회피

    위에 예시한 것과 비슷한 문제로
//emlist{
              if (a==b)
                 if (c==d) foo();
              else bar();
//}
    라는 식으로 코딩을 하면 귀찮은 문제가 발생한다.위 프로그램은
//emlist{
              if (a==b) {
                 if (c==d) foo();
                 else bar();
              }
//}
    로 해석된다.

  * 가독성 향상

    다른 의견이 있기는 하지만 end를 통해 블록 구조를 마무리함으로써
    프로그램이 읽기 쉬워진다고 생각하는 사람들이 많다.

  * begin, case 구문상의 문제

    솔직히 말해서 matz는 end라는 이름의 변수를 사용하려고 하다
    큰 일을 치른 적이 몇 번이고 있다고 한다.그런 이유로 {} 문법을 사용하는 것도
    검토했지만 begin과 case
    문법이 깔끔하게 정리되지 않아서 이 안은 폐기했다.사실은 이게 가장 큰
    이유라는 이야기가 있다.


: ENV
  환경변수에 접근하기 위한 [[c:Hash]]
  처럼 작동하는 객체.사실은 특이 메소드를 추가한
  [[c:Object]] 클래스의
  인스턴트이다이 객체에 의해서
  환경변수를 변경하면
  Ruby의 자식 프로세스가 이 환경변수를 계승한다.


=== F


: FAQ
: Frequently Asked Questions
  자주 있는 질문과 그 답변집#@#   [[unknown:Ruby FAQ]]은 아직 추가되는 중입니다.질문과 답변 수시모집중.


=== G


: goto
  Ruby에는 없는 문법.goto가 없는 이유는 '있어서는 안되는 존재'이기 때문이 아니라,
  '구현하는 게 귀찮아서'였다고 한다.
  goto 대신 catch/throw로 예외처리가 구현되어 있다.

=== H
=== I
=== J


: JARH
: Just another Ruby hacker,

=== K
=== L
=== M


: main
  톱 레벨의 self.
  self가 없을 수는 없는 관계로 단지 거기에 존재하기
  위한 이유만으로 존재하는 Object 클래스의 인스턴스지만,
  Object 클래스를 다루기 위해 몇가지 특이 메소드가 정의되어
  있다.

  정의되어 있는 특이 메소드는

  * private

  * public

  * include


: matz
  Ruby를 만든 사람.마츠모토 유키히로라고도 한다.
  [[url:http://cmail.sourceforge.jp/]]
  와 네 아이의 아버지이다.

: 믹스인
: Mix-in
  아이스크림에 이런저런 것들을 섞어서 새로운 맛을 내는 방법.여기서 착안한 명칭으로
  모듈을 클래서와 섞어서 새로운 기능을 추가하는
  방법을 의미한다.상속을 참조할 것.

  Ruby에서는 다중상속을 받아들이지 않고 is-a 관계를 위한 상속과 기능만을
  공유하기 위한 Mix-in이 마련되어있다.다중상속을 남용할 경우
  상속관계가 복잡해진다는 matz의 신념하에 이렇게 설계되었다.

=== N
=== O
=== P


: Perl
  뭐더라?

: POLS
  Principle of least surprise

: Python
  Ruby의 라이벌'나이 먹은 뱀'/matz가 Python에 만족했더라면
  Ruby는 태어나지 못 했을 테지.신경쓰이는 건 이름의 길이가
  6자라는 점.

=== Q
=== R


: RAA
  Ruby Application Archive([[url:http://www.ruby-lang.org/en/raa.html]])

: RCR
  Ruby Change Request

: RD
  Ruby Document

: Ruby
  객체 지향 스크립트 언어.Ruby의 이름은 'Perl을 잇는다
  (pearl은 6월의 탄생석, Ruby는 7월의 탄생석)'는 의미를 가지고
  지어졌다.Ruby는 줄임말이 아니다.

=== S


: Sather
  객체 지향 프로그래밍 언어.matz는
  Eiffel보다 Sather를 좋아한다.하지만
  Sather도 역시 Ruby와는 별로 닮지 않았다.

: self
  리시버식를 참조하는 왜
  self냐면 메소드를
  동사로 생각해봤을 때 리시버는 주어에 해당하고 따라서 메소드가 본
  자신을 나타낸다는 설이 있지만 Ruby에선 
  별 생각없이 Smalltalk를 따라했다는
  설이 유력하다

: Smalltalk
  객체 지향 프로그래밍 언어. 
  객체지향이라는
  패러다임의 기초를 세운 언어.

: super
  オーバーライドしたメソッドから上位のメソッドを呼び出す方法。  引数を省略した時には呼び出し元のメソッドと同じ引数で呼び出さ
  れる。


  * 문제

    인수로 주어진 변수의 값이 변경되는 경우
    super의 원래 값을 받는지, 변경한 값을 받는지//emlist{
              def foo(a)
                 print a
              end
              def self.foo(a)
                a=25
                super
              end
              foo(5)    # 5 or 25??//}
  * 답:

    변경한 값(25)오래된 버전에서는 5를 리턴했다.이제
    이 문제는 크게 의미가 없을 지도 모른다.

=== T


: Thread
  Thread of control의 줄임말일련의 제어흐름.Ruby에선
  하나의 프로그램 안에서 복수의 쓰레드가 존재할 수 있다.

=== U


: undef
  메소드를 정의하지 않은 상태로 설정한다.상속도
  Mix-in도 클래스에 메소드를 추가하는 것이 가능한데
  undef를 사용하면 특정 메소드를 삭제할 수
  있다.하지만 클래스 구현에 필요한 메소드, 즉 메소드 내부에서 사용되는 메소드를
  삭제하면 정상 작동하지 않을 수 있으므로 주의를 요한다.

=== V
=== W
=== X
=== Y
=== Z

=== あ


: 얕은 복
: Shallow copy
  인스턴스의 얕은 복제.
  필드 내의 인스턴스는 참조 카피만 이루어진다.
  예를 들어 배열을 얕은 복제하게 되면 배열은 복제되지만 
  배열 안의 요소가 참조하고 있는 객체들은 복사되지 않는다.
  うっかり破壊的なメソッドを使ってしまうと思わぬ所に影響が
  出る恐れがあるため、気をつける必要がある。  対義語 深い複製

: イテレータ
: Iterator
  ブロック付きメソッド呼び出しのこと。  ブロック付きメソッドは当初繰り返し処理を行うために作られたため、
  未だにイテレータと呼ぶことがある。  繰り返しを意図したメソッドをイテレータと呼ぶのはかまわないが、
  ブロック付きメソッド呼び出し全般をイテレータと呼ぶと混乱の元
  になるので気を付けるように。

: インスタンス
: Instance
  オブジェクトのこと。オブジェクトがある
  クラスに所属することを強調する意味あいがあるらしい。オブジェ
  クトなんだかインスタンスなんだか混乱してオブジェクト指向に挫
  折する人は多いと聞く。

: インスタンス変数
: Instance Variable
  オブジェクトに固有の変数のこと。Rubyのインスタンス変数は識別
  子の直前に@をつけたものであり、メソッドの中から
  しか参照できない。

: オーバーライド
: Override
  再定義のこと。スーパークラスまた
  はincludeしているモジュールで定義され
  ているメソッドと同じ名前のメソッドを定義すること。オーバーラ
  イドした上位のメソッドは
  superを使って呼び出すこと
  ができる。

: オブジェクト
: Object
  もののこと。「愛」は多分オブジェクトではな
  いが、「ラブレター」はオブジェクトである。あるものがものであ
  るか、そうでないかは多分に哲学的である。この辺がオブジェクト
  指向は難しいといわれる原因かも知れない。コンピュータ業界では
  メモリ中の特定の空間のことをオブジェクトと呼ぶ人がいたりする
  人がいる。困ったものだ。カプセル化、
  抽象データ型参照。

: オブジェクト指向
  オブジェクトを基本にしたパラダイム。  英語の"Object-Oriented"という形容詞が、日本に来て名詞化した。  オブジェクトを考え方の中心に置けば、なんでも良いようにも思え
  るが、一般的には

  * 継承

  * カプセル化

  * ポリモルフィズム

    (あるいは動的結合)

  が必要らしい。  なんでも解決できる「魔法」のように考える人もいるが、世の中そ
  んなに甘くない。誕生から20数年を経てようやっと実用的に使われ
  るようになった…んだろうな、多分。

: オブジェクト指向設計
: Object-Oriented Design
  オブジェクトを基本にしたシステム設計

: オブジェクト指向プログラミング
: Object-Oriented Programming
  オブジェクトを基本にしたプログラミング。

: オブジェクト指向分析
: Object-Oriented Analysis
  オブジェクトを基本にしたシステム分析。


=== か


: カプセル化
: Encapsulation
  データに対する直接的な操作はデータの型に付随する特定の手続き
  (メソッドと呼ぶ)からだけ行うことにより、
  内部構造や処理のアルゴリズムを外部から隠してしまうこと。  抽象データ型参照。

  Rubyはインスタンス変数はメソッドからしか参照できないので、カ
  プセル化が強制されているといえる。

: 環境変数
: Environment Variable
  親プロセスから子プロセスに対して受け渡される値。  ENVでアクセスされる。  子プロセスに渡るのは環境変数のコピーなので、子プロセスから親
  プロセスに環境変数を使って情報を受け渡すことはできない。  親はなかなか子供に耳を傾けないものである。

: 関数
: Function
  厳密にいうとRubyに関数はない。しかし、レシーバを省略したメソッ
  ド呼び出しは外見が関数に似ているし、
  selfやインスタンス変数など
  レシーバの情報を全く参照しない事実上の関数として働いていると
  いっても良いメソッドもある。だから厳密でない言い方としてそう
  いうメソッドを関数と呼ぶこともある。

  そういう関数(的メソッド)は大抵レシーバを省略した形式でしか呼
  び出せないように可視性がprivateに
  設定してある。このようなメソッドの代表として
  モジュール関数がある。

: クラスメソッド
: Class Method
  クラスのメソッド。全てのクラスのクラス
  [[c:Class]]で定義されている
  全てのクラスで共有されているメソッドとクラスそれぞれが固有に持っている
  特異メソッドとがあるが、そんな
  ことは大した問題ではない。  クラスメソッド内でのselfはクラスであるので勘違いしないように。

: グローバル変数
: Global Variable
  プログラム全体から参照できる変数。危険。多用しないこと。

: 継承
: Inheritance
  先祖や親戚から受け継いだものに頼り切って、
  自分では最低限のことしかしないこと。現実世界では嫌な奴。  転じて、あるクラスに機能を追加した新しいクラス
  を作ること。継承はis-aの関係を表現するのに有効である。たとえ
  ば、学生一般の性質を記述した「学生」クラスを継承して、実験に
  苦しめられる「工学部生」クラスを作ることができる。is-aの関係
  がなく、単に性質や機能を共有する場合にはMix-in
  を使うことが望ましいとされる。


=== さ


: 再定義
: Redefinition
  オーバーライドのこと。

: 辞書
: Dictionary
  項目からその定義を取り出すことができるもの。転じて
  ハッシュの別名。オブジェクト指向の起源と
  も呼べるSmalltalkにおいてハッシュに
  相当するデータ構造が「辞書」と呼ばれていたせいで辞書という用
  語になじんでいる一群の人々がいる。

: 初期化
: Initialize
  オブジェクト(あるいは「なにか」)を「使える」状態にすること。  インスタンスの初期化には
  [[m:Object#initialize]]
  メソッドを再定義する。クラスのメソッド
  [[m:Class#new]]のデフォルトの
  定義は新たに生成したインスタンスに対して、
  initializeを実行する。newへの
  引数はそのままinitializeに渡される。また、
  newがブロックとともに呼び出された時には
  initializeにそのブロックがそのまま与えられる。

  ということは[[m:Class#new]]
  を再定義する必要はないはずだ。

: スクリプト
: Script
  台本。転じて、インタープリタが解釈する比較的短いプログラムの
  こと。もちろん中には超大作の台本もある。

: スクリプト言語
: Script Language
  スクリプトに従ってバッチ処理を行うイン
  タープリタのこと。人間も台本を読むという点においてスクリプト
  言語である。

: 即値
: Immediate Value
  参照ではなく、実際の値が変数に格納さ
  れるもの。Rubyの現在の実装ではFixnum、Symbolとnil/true/falseだけが即
  値である。しかし、Fixnumが即値でないRubyの実装があっても構わ
  ないし、モデル上全ての値がオブジェクトへの参照であると考えて
  も差し支えない。

: ソート
: Sort
  順番に並べ替えること。Ruby は数え上げる事ができて
  (Enumerable がincludeされていて)、各要素に順序
  が定義されて(<=> が定義されて)いれば、配列に限らずどん
  な複雑なオブジェクトの集まりもソートしてくれる。


=== た


: 大域脱出
: Non-Local Exit
  break, next, redo, retry, return
  などのメソッドの範囲内での脱出ではなく、捕捉されない限りメソッ
  ド呼び出しの階層を遡って中断するタイプのものを大域脱出と呼ぶ。  Rubyの大域脱出には、例外によるものとcatch/throwがある。

  ほとんどの例外は(exitで発生するSystemExit
  を含めて rescue で捕捉できるが、捕捉することに意味がない例外
  (例:メモリ割当に失敗した/インタプリタそのもののバグ)は
  捕捉の対象にならない。

  catch/throwはthrowされると指定されたタグと同じ
  タグを持つcatchまで一気にジャンプするものである。

: ダイナミックローカル変数
: Dynamic Local Variable
  ローカル変数 の一種。Rubyのローカル変数はスコープが
  静的に決まるためコンパイル時に変数が作成されるが、ダイナミックローカ
  ル変数は、実行の都度変数が作成される。ブロックの中で初めて代入された
  ローカル変数はダイナミックローカル変数となり、そのスコープはブロック
  の中だけとなる。これは、Thread 毎に独立した変数を持
  つためにある。

: 抽象データ型
: Abstract Data Type
  データの構造とそのデータに対する操作をひとまとめにしたものを
  抽象データ型と呼ぶ。抽象データに対する操作は必ずその操作を経
  由する必要がある。結果、データ構造は外部からは直接参照されず、
  内部構造の変更が外部に悪影響を及ぼさない。このことを
  カプセル化と呼ぶ。

: 定数
: Constant
  一度定義したら値を変えることができない変数。  でも、この定義は矛盾しているなあ。

: 動的結合
: Dynamic Binding
  操作の対象のデータ型に合わせて適切な手続き(メソッド)が実行時
  に選択されること。プログラムの柔軟性を高める働きがある。  オブジェクト指向の要件のひとつ。  Rubyでは変数に型が無いので動的結合は必然である。

: 特異クラス
: Singleton Class
  ある特定のオブジェクトだけのための仮想的なクラス。

: 特異メソッド
: Singleton Method
  ある特定のオブジェクトにだけ定義されたメソッド。  メソッド参照。  特異メソッドは以下の場合に他のオブジェクトにも引き継がれる。

  * [[m:Object#clone]]した場合

  * サブクラスを作った場合

  特異メソッドで元のクラスのメソッドをオーバーライドした場合は
  もとのメソッドは super で呼び出すことができる。

: ドキュメント
: Document
  matzの苦手なもの。彼は普段から「ソースがドキュメントだ。バグ
  も完全に記述されている」と主張しているが、誰も受け入れない。  当り前だ。

: トップレベル
: Top Level
  クラス／モジュール定義の一番外側のコンテキスト。Rubyスクリプトはトップレベルの
  コンテキストから処理が始まる。

  いきなり、
    print "on Toplevel"
  というスクリプトを書いたとき、print メソッドはトップレベルから呼ばれている。

  トップレベルの self は main を指す。

=== な
=== は


: バイトオーダー
: Byte Order
  0x01020304という4バイトデータを1,2,3,4
  と配置するか、4,3,2,1と配置するかということ。前
  者をビッグエンディアン、後者を
  リトルエンディアンと呼ぶ。どちらが
  良いかという論争は時のはじめから続いていてまだ結論が出ていない。

: 破壊的
: Destructive
  [[m:String#chop!]], [[m:Array#concat]] などの
  メソッドは、レシーバの状態を変化させるので、
  「破壊的な作用をする」という。  めったにコンピュータを壊すことはない。

: ハッシュ
: Hash
  Rubyにおけるキーから値へのマッピングを表すデータ構造。  連想配列とか辞書とも呼ばれる。ハッシュがハッシュ
  と呼ばれるのはその実現に「ハッシュ表」と呼ばれるアルゴリズム
  が使われているからである。ハッシュというのは「切り刻む」とい
  う意味で、「ハッシュド・ビーフ」の「ハッシュ」である。

: パラダイム
: Paradigm
  「考え方」の難しい表現。素直に分かりやすい言葉を使えばいいのに…。

: ヒアドキュメント
: Here Document
  [[ref:d:spec/literal#here]] を参照してください。

: ビッグエンディアン
: Big Endian
  アメリカ大陸原住民…はインディアン。  こっちはエンディアンで語源はスウィフトの「ガリバー旅行記」に出て来る
  卵を丸い端から食べる人たちである。  当然、尖った端から食べる人たちは
  リトルエンディアンである。  コンピュータ業界ではCPUなどがデータを並べる時の形式のひとつで、
  ネットワーク族はビッグエンディアンを好むという。  バイトオーダー参照

: ビルトインクラス
: Built-In Class
  Rubyインタプリタ組み込みでインスタンスの構造が
  通常のオブジェクトと異なるクラス。  これらのクラスを継承したクラスを定義することはお勧めしない。  Rubyのビルトインクラスは [[lib:_builtin]] に列挙されている。

: 深い複製
: deep copy
  インスタンスの深いコピー。  フィールド内にインスタンスがある場合、
  そのインスタンス専用にメモリのコピーを行う。  例えば、配列に深い複製を行った場合、配列をコピーし、
  配列内の要素が参照しているオブジェクトもすべてコピーされる。  対義語 浅い複製 shallow copy

: ブロック
: Block
  ループを構成したり、家や塀を建てたり、人を殴ったりするもの。

: ブロック付きメソッド呼び出し
  コードの集まり(ブロック)を受け取ることのできるメソッドを
  ブロック付きメソッド呼び出しと呼ぶ。

  ブロック付きメソッドの中では yield を使って
  ブロックを実行することができる。

  当然のことながら、与えられたブロックをどのように処理するかは
  メソッド側に委ねられている。ので、内部でブロックを評価しない
  メソッドにブロックを与えてもなにも起きない。エラーも起きない。

: ブロック引数
: Block argument
  メソッド定義時などに使用する &block などのこと。

: ブロックパラメータ
: Block parameter
  ブロックに渡すパラメータのこと。

: 変数
: Variable
  オブジェクトにつける名札。Rubyの変数には
  グローバル変数、ローカル変数、インスタンス変数がある。  それと定数は値を変えることができないので、変数ではないが、
  名札であるという点においては変数と同じである。

: ポリモルフィズム
: 多態, Polymorphism
  対象になるオブジェクトによって実際の操作が決定されること。  Rubyではレシーバのオブジェクトに応じ
  てメソッドが選択されることによって実現されている。


  * 例
//emlist{
              obj = "abc"
              print obj.length, "\n"          # => 3
              obj = [1,2,3,4]
              print obj.length, "\n"          # => 4
//}

=== ま


: モジュール関数
: Module Function
  関数のように用いられるメソッドの中で、
  モジュールのメソッドとしても、特異メソッドとしても定義されて
  いるものはモジュール関数と呼ばれる。例えば
  [[c:Math]]モジュールのほとんどのメソッドは
  モジュール関数である。これらのメソッドは、例えば

            Math.sqrt(2)

  という形式でも

            include Math
            sqrt(2)

  という形式でも使えて便利である。

: メソッド
: Method
  オブジェクトに対する操作。操作対象のオ
  ブジェクト(レシーバ)は self で参照できる。  Rubyの場合ビルトインクラスのオブジェクトを除けば、
  オブジェクトの構造は動的に決まるので、
  あるオブジェクトの性質はそのオブジェクトに定義されているメソッド
  によって決定される。

=== や
=== ら


: リトルエンディアン
: Little Endian
  最初10人いて段々減っていく。コンピュータ業界ではデータを並べ
  る時の形式のひとつで、非常に大きなシェアを持つあるCPUメーカー
  はリトルエンディアンを好むという。バイトオーダー参照

: 例外
: Exception
  例外的な状況で発生するもの。例外が発生すると
  begin の rescue 節を使って明示的に捕捉されない限り、
  呼び出し階層を遡ってプログラム(thread)の実行は中断される。例外の
  おかげでRubyプログラムはほとんどの場合例外的な状況についていちいち
  チェックせずにすむ。例外の発生した場所の情報は [[m:$@]] に、
  例外そのものに関する情報は [[m:$!]] に格納されている。

: レシーバ
: Receiver
  メソッドの実行主体。メソッド呼び出し式の`.'の左
  側にあるもの。メソッド内では
  self で参照できる。レシーバのインスタンス変数は
  @変数名という形式でアクセスできる。

: 連想配列
: Associative Array
  ハッシュの別名。ハッシュが任意のキーから
  値を取り出すことができるので、「連想」と、またハッシュは添字
  が数字でない配列とみなすことができるので「配列」と呼ぶらしい。  昔々は連想配列(連想記憶と呼ばれていた)はハードウェアによって
  実現されるものだと考えられていたが、計算速度の向上や適切なア
  ルゴリズムの発見(「ハッシュ表」と呼ぶ。ハッシュの語源)により
  ソフトウェアのみによって実現されるようになった。

: ローカル変数
: Local Variable
  ある範囲内でのみ参照可能な変数。その範囲をスコープと呼ぶ。  Rubyのスコープは

  * プログラム全体

  * クラス・モジュール定義

  * メソッド定義

  * ブロック

  で、ブロックだけは外側のスコープのローカル変数もアクセスでき
  る。ローカル変数の有効範囲はスコープでの最初の代入が現れた場
  所からスコープの終りまでである。有効範囲は静的に決まり、実際
  に実行されるかどうかは関係ない。

=== わ
=== Symbol
