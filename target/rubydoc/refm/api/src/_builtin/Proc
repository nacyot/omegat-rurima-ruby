= class Proc < Object

ブロックをコンテキスト(ローカル変数のスコープやスタックフ
レーム)とともにオブジェクト化した手続きオブジェクトです。

Proc は ローカル変数のスコープを導入しないことを除いて
名前のない関数のように使えます。ダイナミックローカル変数は
Proc ローカルの変数として使えます。

Proc がローカル変数のスコープを保持していることは以下の例で
変数 var を参照できていることからわかります。

  var = 1
  $foo = Proc.new { var }
  var = 2
  
  def foo
    $foo.call
  end
  
  p foo       # => 2

#@include(lambda_proc)


== Class Methods

--- new -> Proc
--- new { ... } -> Proc

ブロックをコンテキストとともにオブジェクト化して返します。

ブロックを指定しなければ、このメソッドを呼び出したメソッドが
ブロックを伴うときに、それを Proc オブジェクトとして生成して返します。

  def foo
    pr = Proc.new
    pr.call(1)
  end
  foo {|arg| p arg }
  # => 1

これは以下と同じです。

  def foo
    yield(1)
  end
  foo {|arg| p arg }
  # => 1

呼び出し元のメソッドがブロックを伴わなければ、例外
[[c:ArgumentError]] が発生します。

  def foo
    Proc.new
  end
  foo
  # => -:2:in `new': tried to create Proc object without a block (ArgumentError)
          from -:2:in `foo'
          from -:4

Proc.new は、Proc#initialize が定義されていれば
オブジェクトの初期化のためにこれを呼び出します。このことを
除けば、[[m:Kernel.#proc]] と同じです。


== Instance Methods

--- [](*arg) -> ()
--- call(*arg) -> ()
#@since 1.9.1
--- ===(*arg) -> ()
--- yield(*arg) -> ()
#@end

手続きオブジェクトを実行してその結果を返します。

#@until 1.9.1
引数はブロックパラメータにそのまま(多重代入のルールに従い)代入されます。
#@else
引数の渡され方はオブジェクトの生成方法によって異なります。
詳しくは [[m:Proc#lambda?]] を参照してください。

「===」は when の所に手続きを渡せるようにするためのものです。

  def sign(n)
    case n
    when lambda{|n| n > 0} then 1
    when lambda{|n| n < 0} then -1
    else 0
    end
  end
  
  p sign(-4) #=> -1
  p sign(0)  #=> 0
  p sign(7)  #=> 1
#@end


@param arg 手続きオブジェクトに与える引数を指定します。

@raise LocalJumpError Procを生成したメソッドからリターンしてしまった場合に発生します。

#@# 2.0 では削除されている事、実装に依存する内容である事から省略。
#@# 参照: プログラミング言語 Ruby p203
#@##until 2.0.0
#@#--- ==(other)   -> bool
#@##@since 1.9.1
#@#--- eql?(other) -> bool
#@##@end
#@#
#@# --- clone -> Proc
#@# nodoc
#@# --- dup -> Proc
#@# nodoc

--- arity -> Fixnum

Proc オブジェクトが受け付ける引数の数を返します。

ただし、可変長引数を受け付ける場合、負の整数

  -(必要とされる引数の数 + 1)

を返します。

예:

#@since 1.9.1
 lambda{           }.arity   # => 0
 lambda{||         }.arity   # =>  0
 lambda{|x|        }.arity   # =>  1
 lambda{|*x|       }.arity   # => -1
 lambda{|x, y|     }.arity   # =>  2
 lambda{|x, *y|    }.arity   # => -2
 lambda{|(x, y)|   }.arity   # =>  1
 lambda{|(x, y), z|}.arity   # =>  2
#@else
 lambda{           }.arity   # => -1
 lambda{||         }.arity   # =>  0
 lambda{|x|        }.arity   # =>  1
 lambda{|*x|       }.arity   # => -1
 lambda{|x, y|     }.arity   # =>  2
 lambda{|x, *y|    }.arity   # => -2
 lambda{|(x, y)|   }.arity   # =>  2
 lambda{|(x, y), z|}.arity   # =>  2
#@end

--- binding -> Binding

Proc オブジェクトが保持するコンテキストを 
[[c:Binding]] オブジェクトで返します。

--- to_proc -> self

self를 리턴합니다.

--- to_s    -> String
#@since 2.0.0
--- inspect -> String
#@end

self の文字列表現を返します。

可能なら self を生成したソースファイル名、行番号を含みます。

  p Proc.new {
     true
  }.to_s

  => "#<Proc:0x0x401a880c@-:3>"

#@since 1.9.1
--- curry         -> Proc
--- curry(arity)  -> Proc
Procをカリー化します

カリー化したProcはいくつかの引数をとります。十分な数の引数が与えられると、元のProcに引数を渡し
て実行し、結果を返します。引数の個数が足りないときは、部分適用したカリー化Procを返します。

@param arity 引数の個数を指定します
@return カリー化したProcオブジェクトを返します

  b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
  p b.curry[1][2][3]           #=> 6
  p b.curry[1, 2][3, 4]        #=> 6
  p b.curry(5)[1][2][3][4][5]  #=> 6
  p b.curry(5)[1, 2][3, 4][5]  #=> 6
  p b.curry(1)[1]              #=> 1

  b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
  p b.curry[1][2][3]           #=> 6
  p b.curry[1, 2][3, 4]        #=> 10
  p b.curry(5)[1][2][3][4][5]  #=> 15
  p b.curry(5)[1, 2][3, 4][5]  #=> 15
  p b.curry(1)[1]              #=> 1

  b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
  p b.curry[1][2][3]           #=> 6
  p b.curry[1, 2][3, 4]        #=> wrong number of arguments (4 or 3)
  p b.curry(5)                 #=> wrong number of arguments (5 or 3)
  p b.curry(1)                 #=> wrong number of arguments (1 or 3)

  b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
  p b.curry[1][2][3]           #=> 6
  p b.curry[1, 2][3, 4]        #=> 10
  p b.curry(5)[1][2][3][4][5]  #=> 15
  p b.curry(5)[1, 2][3, 4][5]  #=> 15
  p b.curry(1)                 #=> wrong number of arguments (1 or 3)

  b = proc { :foo }
  p b.curry[]                  #=> :foo

--- lambda?-> bool
手続きオブジェクトの引数の取扱が厳密であるならば true を返します。


引数の取扱の厳密さの意味は以下の例を参考にしてください。예:
  # lambda で生成した Proc オブジェクトでは true 
  lambda{}.lambda?# => true
  # proc で生成した Proc オブジェクトでは false
  proc{}.lambda?# => false
  # Proc.new で生成した Proc オブジェクトでは false
  Proc.new{}.lambda?# => false
  
  # 以下、lambda?が偽である場合
  # 余分な引数を無視する
  proc{|a,b| [a,b]}.call(1,2,3) # => [1,2]
  # 足りない引数には nil が渡される
  proc{|a,b| [a,b]}.call(1) # => [1, nil]
  # 配列1つだと展開される
  proc{|a,b| [a,b]}.call([1,2]) => [1,2]
  # lambdaの場合これらはすべて ArgumentError となる
   
  # &が付いた仮引数で生成される Proc は lambda?が偽となる
  def n(&b) b.lambda?end
  n {} # => false
  
  # &が付いた実引数によるものは、lambda?が元の Procオブジェクトから
  # 引き継がれる
  lambda(&lambda {}).lambda?#=> true
  proc(&lambda {}).lambda?#=> true
  Proc.new(&lambda {}).lambda?#=> true
  
  lambda(&proc {}).lambda?#=> false
  proc(&proc {}).lambda?#=> false
  Proc.new(&proc {}).lambda?#=> false
  
  n(&lambda {})                #=> true
  n(&proc {})                  #=> false
  n(&Proc.new {})              #=> false
  
  # Method#to_proc によるものは lambda?が真となる
  def m() end
  method(:m).to_proc.lambda?#=> true
  
  # Module#define_method は特別扱いで、
  # これで定義されたメソッドの引数は常に厳密に取り扱われる
  class C
    define_method(:d) {}
  end
  C.new.d(1,2)       #=> ArgumentError
  C.new.method(:d).to_proc.lambda?#=> true

  class C
    define_method(:e, &proc {})
  end
  C.new.e(1,2)       #=> ArgumentError
  C.new.method(:e).to_proc.lambda?#=> true

--- source_location -> [String, Fixnum] | nil
ソースコードのファイル名と行番号を配列で返します。

その手続オブジェクトが ruby で定義されていない(つまりネイティブ
である)場合は nil を返します。

@see [[m:Method#source_location]]

--- hash -> Integer

self のハッシュ値を返します。

#@end
#@since 1.9.2
--- parameters -> [object]
Proc オブジェクトの引数の情報を返します。

Proc オブジェクトが引数を取らなければ空の配列を返します。引数を取る場合は、配列の配列を返し、
各配列の要素は引数の種類に対応した以下のような Symbol と、引数名を表す Symbol の 2 要素です。

: :req
 必須の引数
: :opt
 デフォルト値が指定されたオプショナルな引数
: :rest
 * で指定された残りすべての引数
: :block
 & で指定されたブロック引数

예:
  prc = lambda{|x, y=42, *other, &b|}
  prc.parameters #=> [[:req, :x], [:opt, :y], [:rest, :other], [:block, :b]]

@see [[m:Method#parameters]], [[m:UnboundMethod#parameters]]
#@end
